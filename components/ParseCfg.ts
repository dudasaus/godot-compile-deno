/** Generated by Gemini. */

export interface CfgObject {
  [key: string]: string | number | boolean | CfgObject | (string | number | boolean)[];
}

export function parseCfg(cfgContent: string, ignoreOptions: boolean = false): CfgObject {
  const result: CfgObject = {};
  const lines = cfgContent.split('\n');
  let currentSection: string | null = null;

  for (const line of lines) {
    const trimmedLine = line.trim();

    if (trimmedLine.startsWith('#') || trimmedLine === '') {
      continue; // Skip comments and empty lines
    }

    if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
      // Section header
      currentSection = trimmedLine.slice(1, -1).trim();
      if (ignoreOptions && currentSection.endsWith(".options")) {
        currentSection = null; // Ignore this section
        continue;
      }
      if (!result[currentSection]) {
        result[currentSection] = {};
      }
      continue;
    }

    if (currentSection && trimmedLine.includes('=')) {
      const parts = trimmedLine.split('=');

      if (parts.length === 2) {
        const key = parts[0].trim();
        const value = parts[1].trim();

        // Attempt to parse value as different types
        let parsedValue: string | number | boolean | CfgObject | (string | number | boolean)[];
        if (value.toLowerCase() === 'true') {
          parsedValue = true;
        } else if (value.toLowerCase() === 'false') {
          parsedValue = false;
        } else if (!isNaN(Number(value))) {
          parsedValue = Number(value);
        } else if (value.startsWith('[') && value.endsWith(']')) {
          // Attempt to parse array
          const arrayString = value.slice(1, -1).trim();
          if (arrayString === "") {
            parsedValue = [];
          } else {
            const arrayValues = arrayString.split(',').map(item => item.trim());
            const parsedArray: (string | number | boolean)[] = [];
            for (const item of arrayValues) {
              if (item.toLowerCase() === 'true') {
                parsedArray.push(true);
              } else if (item.toLowerCase() === 'false') {
                parsedArray.push(false);
              } else if (!isNaN(Number(item))) {
                parsedArray.push(Number(item));
              } else {
                parsedArray.push(item);
              }
            }
            parsedValue = parsedArray;
          }
        } else if (value.startsWith('{') && value.endsWith('}')) {
          // Attempt to parse object
          const objectString = value.slice(1, -1).trim();
          if (objectString === "") {
            parsedValue = {};
          } else {
            const objectParts = objectString.split(',').map(item => item.trim());
            const parsedObject: CfgObject = {};
            for (const pair of objectParts) {
              const keyValue = pair.split(':');
              if (keyValue.length === 2) {
                const innerKey = keyValue[0].trim();
                const innerValue = keyValue[1].trim();

                if (innerValue.toLowerCase() === 'true') {
                  parsedObject[innerKey] = true;
                } else if (innerValue.toLowerCase() === 'false') {
                  parsedObject[innerKey] = false;
                } else if (!isNaN(Number(innerValue))) {
                  parsedObject[innerKey] = Number(innerValue);
                } else {
                  parsedObject[innerKey] = innerValue;
                }
              }
            }
            parsedValue = parsedObject;
          }
        } else {
          parsedValue = value;
        }

        if (currentSection && result[currentSection] && typeof result[currentSection] === 'object' && result[currentSection] !== null) {
          (result[currentSection] as CfgObject)[key] = parsedValue;
        }
      }
    }
  }

  return result;
}
